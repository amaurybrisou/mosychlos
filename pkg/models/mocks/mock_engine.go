// Code generated by MockGen. DO NOT EDIT.
// Source: engine.go

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	bag "github.com/amaurybrisou/mosychlos/pkg/bag"
	models "github.com/amaurybrisou/mosychlos/pkg/models"
	gomock "github.com/golang/mock/gomock"
)

// MockToolProvider is a mock of ToolProvider interface.
type MockToolProvider struct {
	ctrl     *gomock.Controller
	recorder *MockToolProviderMockRecorder
}

// MockToolProviderMockRecorder is the mock recorder for MockToolProvider.
type MockToolProviderMockRecorder struct {
	mock *MockToolProvider
}

// NewMockToolProvider creates a new mock instance.
func NewMockToolProvider(ctrl *gomock.Controller) *MockToolProvider {
	mock := &MockToolProvider{ctrl: ctrl}
	mock.recorder = &MockToolProviderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockToolProvider) EXPECT() *MockToolProviderMockRecorder {
	return m.recorder
}

// Defs mocks base method.
func (m *MockToolProvider) Defs() []models.ToolDef {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Defs")
	ret0, _ := ret[0].([]models.ToolDef)
	return ret0
}

// Defs indicates an expected call of Defs.
func (mr *MockToolProviderMockRecorder) Defs() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Defs", reflect.TypeOf((*MockToolProvider)(nil).Defs))
}

// Get mocks base method.
func (m *MockToolProvider) Get(name string) models.Tool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", name)
	ret0, _ := ret[0].(models.Tool)
	return ret0
}

// Get indicates an expected call of Get.
func (mr *MockToolProviderMockRecorder) Get(name interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockToolProvider)(nil).Get), name)
}

// List mocks base method.
func (m *MockToolProvider) List() []models.Tool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "List")
	ret0, _ := ret[0].([]models.Tool)
	return ret0
}

// List indicates an expected call of List.
func (mr *MockToolProviderMockRecorder) List() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "List", reflect.TypeOf((*MockToolProvider)(nil).List))
}

// MockToolConsumer is a mock of ToolConsumer interface.
type MockToolConsumer struct {
	ctrl     *gomock.Controller
	recorder *MockToolConsumerMockRecorder
}

// MockToolConsumerMockRecorder is the mock recorder for MockToolConsumer.
type MockToolConsumerMockRecorder struct {
	mock *MockToolConsumer
}

// NewMockToolConsumer creates a new mock instance.
func NewMockToolConsumer(ctrl *gomock.Controller) *MockToolConsumer {
	mock := &MockToolConsumer{ctrl: ctrl}
	mock.recorder = &MockToolConsumerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockToolConsumer) EXPECT() *MockToolConsumerMockRecorder {
	return m.recorder
}

// ConsumeTools mocks base method.
func (m *MockToolConsumer) ConsumeTools(ctx context.Context, key bag.Key) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ConsumeTools", ctx, key)
	ret0, _ := ret[0].(error)
	return ret0
}

// ConsumeTools indicates an expected call of ConsumeTools.
func (mr *MockToolConsumerMockRecorder) ConsumeTools(ctx, key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ConsumeTools", reflect.TypeOf((*MockToolConsumer)(nil).ConsumeTools), ctx, key)
}

// GetRemainingCredits mocks base method.
func (m *MockToolConsumer) GetRemainingCredits() map[bag.Key]int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetRemainingCredits")
	ret0, _ := ret[0].(map[bag.Key]int)
	return ret0
}

// GetRemainingCredits indicates an expected call of GetRemainingCredits.
func (mr *MockToolConsumerMockRecorder) GetRemainingCredits() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRemainingCredits", reflect.TypeOf((*MockToolConsumer)(nil).GetRemainingCredits))
}

// GetUnusedRequiredTools mocks base method.
func (m *MockToolConsumer) GetUnusedRequiredTools() []bag.Key {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetUnusedRequiredTools")
	ret0, _ := ret[0].([]bag.Key)
	return ret0
}

// GetUnusedRequiredTools indicates an expected call of GetUnusedRequiredTools.
func (mr *MockToolConsumerMockRecorder) GetUnusedRequiredTools() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUnusedRequiredTools", reflect.TypeOf((*MockToolConsumer)(nil).GetUnusedRequiredTools))
}

// HasCreditsFor mocks base method.
func (m *MockToolConsumer) HasCreditsFor(toolKey bag.Key) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HasCreditsFor", toolKey)
	ret0, _ := ret[0].(bool)
	return ret0
}

// HasCreditsFor indicates an expected call of HasCreditsFor.
func (mr *MockToolConsumerMockRecorder) HasCreditsFor(toolKey interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasCreditsFor", reflect.TypeOf((*MockToolConsumer)(nil).HasCreditsFor), toolKey)
}

// HasUnusedRequiredTools mocks base method.
func (m *MockToolConsumer) HasUnusedRequiredTools() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HasUnusedRequiredTools")
	ret0, _ := ret[0].(bool)
	return ret0
}

// HasUnusedRequiredTools indicates an expected call of HasUnusedRequiredTools.
func (mr *MockToolConsumerMockRecorder) HasUnusedRequiredTools() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasUnusedRequiredTools", reflect.TypeOf((*MockToolConsumer)(nil).HasUnusedRequiredTools))
}

// Reset mocks base method.
func (m *MockToolConsumer) Reset() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Reset")
}

// Reset indicates an expected call of Reset.
func (mr *MockToolConsumerMockRecorder) Reset() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Reset", reflect.TypeOf((*MockToolConsumer)(nil).Reset))
}

// MockEngine is a mock of Engine interface.
type MockEngine struct {
	ctrl     *gomock.Controller
	recorder *MockEngineMockRecorder
}

// MockEngineMockRecorder is the mock recorder for MockEngine.
type MockEngineMockRecorder struct {
	mock *MockEngine
}

// NewMockEngine creates a new mock instance.
func NewMockEngine(ctrl *gomock.Controller) *MockEngine {
	mock := &MockEngine{ctrl: ctrl}
	mock.recorder = &MockEngineMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockEngine) EXPECT() *MockEngineMockRecorder {
	return m.recorder
}

// Execute mocks base method.
func (m *MockEngine) Execute(ctx context.Context, client models.AiClient, sharedBag bag.SharedBag) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, client, sharedBag)
	ret0, _ := ret[0].(error)
	return ret0
}

// Execute indicates an expected call of Execute.
func (mr *MockEngineMockRecorder) Execute(ctx, client, sharedBag interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockEngine)(nil).Execute), ctx, client, sharedBag)
}

// Name mocks base method.
func (m *MockEngine) Name() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Name")
	ret0, _ := ret[0].(string)
	return ret0
}

// Name indicates an expected call of Name.
func (mr *MockEngineMockRecorder) Name() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Name", reflect.TypeOf((*MockEngine)(nil).Name))
}

// ResultKey mocks base method.
func (m *MockEngine) ResultKey() bag.Key {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ResultKey")
	ret0, _ := ret[0].(bag.Key)
	return ret0
}

// ResultKey indicates an expected call of ResultKey.
func (mr *MockEngineMockRecorder) ResultKey() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ResultKey", reflect.TypeOf((*MockEngine)(nil).ResultKey))
}
